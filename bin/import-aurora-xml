#!/usr/bin/env ruby

require 'argos'

optdef = {
  "h"         => true,
  "help"      => true,
  "log"       => true,
  "emit"      => true,
  "rekey"     => true,
  "dry-run"   => true
}

opts = Argos.parse_options(ARGV, optdef)
p ARGV, opts, ARGV.grep(/^-./)

if ARGV.size == 0 or ARGV.size > 2 or
   not ARGV.grep(/^-./).empty? or opts["h"] or opts["help"]
  puts <<-END
  
    Usage: #{$0} [opts] aurora_xml_file [db]
    
    Read aurora_xml_file, parse according to aurora.xsd, and import into
    a database. Print the scenario id to stderr.
    
    The database is either an in-memory sqlite3 database (for testing) or
    specified by the db argument, which may be any valid database connection
    string:
    
      sqlite://foo.db
      postgres://user:password@host:port/database_name
    
    Options:
    
      --log     Print full SQL log to stderr.
      
      --emit    Emit the xml before it is imported, but after rekeying.
      
      --dry-run Quit before sending anything to the database.
      
      --rekey   Reassign numeric IDs in preparation for importing to DB.
                Non-numeric IDs are unaffected and imported to new rows.
                Use this when the input xml cannot be assumed to
                have been exported from the db.
      
  END
  exit
end

xml_file = ARGV[0]
db_url = ARGV[1]

File.exist? xml_file or abort "no such file: #{xml_file}"

require 'sequel'
require 'nokogiri'

if db_url
  DB = Sequel.connect db_url
else
  DB = Sequel.sqlite
end

if opts["log"]
  require 'logger'
  DB.loggers << Logger.new($stderr)
end

topdir = File.expand_path("..", File.dirname(__FILE__))
libdir = File.join(topdir, "lib")
$LOAD_PATH.unshift libdir

# create tables if they don't exist
require 'db/schema'

require 'db/model/aurora'
require 'db/import/scenario'

module Aurora
  module Parser
    # +src+ can be io, string, etc.
    def parse src
      ## optionally validate
      Nokogiri.XML(src).xpath("/scenario")[0]
    end
  end
  extend Parser
  
  class Importer
    include Parser
    
    attr_reader :src
    attr_reader :opts
    attr_reader :scenario_xml
    attr_reader :scenario
    
    # Set opts["rekey"] to true if the input xml cannot be assumed to have
    # been exported from the db.
    def initialize src, opts = {}
      @src = src
      @opts = opts
    end
    
    # +src+ can be io, string, etc.
    # Returns the ID of the imported scenario.
    def import
      @scenario_xml = parse(src)
      
      if opts["rekey"]
        require 'db/import/util'
        ImportUtil.rekey @scenario_xml
      end
      
      if opts["emit"]
        puts @scenario_xml
      end
      
      if opts["dry-run"]
        return
      end
      
      DB.transaction do
        @scenario = Scenario.create_from_xml(scenario_xml)
      end
      
      return scenario[:id]
    end
    
  end
  
  def self.import src, opts
    Importer.new(src, opts).import
  end
end

sc_id = Aurora.import(File.read(xml_file), opts)

$stderr.puts Aurora::Scenario[sc_id]
