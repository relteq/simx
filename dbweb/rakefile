topdir = File.expand_path("..")
libdir = File.join(topdir, "lib")
$LOAD_PATH.unshift libdir

require 'yaml'

require 'simx/daemon'
##require 'simx/gems'

#== Config

# Read the deployment-specific config file (see config/README).
config = YAML.load(File.read("../config.yaml"))
dbweb_config = config["dbweb"]
aws_config = config["aws"]

ENV["DBWEB_S3_BUCKET"] ||= aws_config["s3 bucket"]

# port served by the daemon process (rake start)
# (with rake run, process port is printed on terminal)
port = Integer(ENV["DBWEB_PORT"] || dbweb_config["port"])

# destination for the remote task
dest_host = config["deploy"]["host"]
dest_path = File.join(config["deploy"]["path"], "dbweb")

proc_name   = "dbweb"
svr_name    = "lib/#{proc_name}.rb"
exec_dir    = ".."
sock_dir    = File.expand_path(File.join(exec_dir, "var/run"))
sock_name   = File.join(sock_dir, "#{proc_name}.sock")
log_dir     = File.expand_path(File.join(exec_dir, "var/log"))
log_file    = File.join(log_dir, "#{proc_name}.log")
err_file    = log_file.sub(/\.log/, ".err")

FileUtils.mkdir_p log_dir
FileUtils.mkdir_p sock_dir

#== Tasks

ops = %w{ start stop restart stat watch log }

desc "update and restart remote daemon, #{dest_host}:#{port}"
task :remote

namespace :remote do
  desc "update to #{dest_host}:#{dest_path}"
  task :update
  
  ops.each do |name|
    desc "#{name} remote daemon"
    task name
  end
end

desc "run child process (not daemon; ^C to stop)"
task :run

desc "start daemon"
task :start

desc "restart daemon"
task :restart

desc "stop daemon"
task :stop

desc "status of daemon"
task :stat

desc "watch new log entries of daemon"
task :watch

desc "browse logs of daemon"
task :log

#== Implementation

include Daemon

task :remote => %w{ remote:stop remote:update remote:start }

remote_files = FileList[
  "rakefile",
  "lib",
]

namespace :remote do
  task :update do
    sh "rsync -Cavz --delete --exclude='*.bck'" +
       " #{remote_files.to_a.join(" ")} #{dest_host}:#{dest_path}/"
  end
  
  ops.each do |name|
    task name do
      sh "ssh #{dest_host} 'cd #{dest_path} && rake #{name}'"
    end
  end
end

task :run do
  sh "ruby", "-C", exec_dir, "-I", File.expand_path(libdir),
    File.expand_path(svr_name)
end

task :start do
  result = command("stat", sock_name)
  case result
  when /not running/i
    puts "starting on port #{port}"
    
    opts = {
      "err_file"    => err_file,
      "log_file"    => log_file,
      "log_params"  => "weekly",
      "sock_name"   => sock_name,
      "daemon_dir"  => exec_dir,
      "proc_name"   => proc_name
    }
    
    args = [
      "-I", File.expand_path(libdir),
      File.expand_path(svr_name),
      "-p", port.to_s,
      "-e", "production",
      "--", # end sinatra options; options below are passed to svr_name
      "--log-file", log_file,
      "--log-level", dbweb_config["log level"]
    ]
    
    daemonize opts do
      exec "ruby", *args
    end
    
    sleep 0.1
    print_stat(sock_name, err_file)
    
  else
    puts result
  end
end

task :stop do
  result = command("stop", sock_name)
  puts result
  FileUtils.rm_f err_file

  case result
  when Errno::ECONNREFUSED, TimeoutError
    rm_f sock_name # assume it is stopped already
  end
end

task :stat do
  print_stat(sock_name, err_file)
  ## could also send a stat request to the web server
end

task :restart => [:stop, :start]

task :watch do
  system "tail -F #{log_file}" # system to suppress error on INT
end

task :log do
  system "less +G --follow-name #{log_file}" # system to suppress error on INT
end

task :test => ["test:import", "test:export"]
  ## check that round trip is ok (how?)

namespace :test do
  task :import do
    sh "cd test && ruby test-import.rb"
  end

  task :export do
    sh "cd test && ruby test-export.rb"
  end
end
